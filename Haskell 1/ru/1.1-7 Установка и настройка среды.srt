1
00:00:00,110 --> 00:00:03,020
Итак, вы реализовали свой
первый модуль на языке Haskell

2
00:00:03,020 --> 00:00:08,539
и загрузили его в интерпретатор, запустив
интерпретатор с именем этого модуля.

3
00:00:08,950 --> 00:00:12,339
Существует конечно и альтернативный
способ, в уже запущеный

4
00:00:12,364 --> 00:00:15,565
интерпретатор мы можем
загружать некоторые модули.

5
00:00:15,820 --> 00:00:17,630
Давайте посмотрим
как это делается

6
00:00:18,030 --> 00:00:20,190
Создадим в текстовом редакторе

7
00:00:20,360 --> 00:00:24,080
новый модуль, реализуем его код

8
00:00:27,740 --> 00:00:29,020
Это модуль с именем Test

9
00:00:29,470 --> 00:00:33,530
в котором определенна
функция <i>sayHello</i>, выводящая

10
00:00:33,870 --> 00:00:36,120
в терминал а следующую строку

11
00:00:36,490 --> 00:00:38,686
"Hello from module Test"

12
00:00:39,430 --> 00:00:41,880
Сохраняем этот файл

13
00:00:42,390 --> 00:00:49,195
под именем Test

14
00:00:49,220 --> 00:00:51,940
указываем расширение что это
модуль на языке Haskell

15
00:00:53,581 --> 00:00:55,745
После того, как наш
редактор понял что это

16
00:00:55,770 --> 00:00:58,234
модуль на языке Haskell,
и он начал раскрашивать

17
00:00:58,620 --> 00:01:04,289
наш код в соответствие с
некоторыми стандартами языка.

18
00:01:05,610 --> 00:01:08,293
Следующая операция которую
нам нужно выполнить

19
00:01:08,318 --> 00:01:14,047
после того, как модуль существует,
нам нужно запустить сначала ghci

20
00:01:14,950 --> 00:01:20,390
Обратите внимание что я нахожусь в
том же самом каталоге где у меня мой

21
00:01:20,390 --> 00:01:23,740
модуль лежит, и теперь мы можем

22
00:01:23,840 --> 00:01:27,390
выполнить команду интерпретатора
которая отвечает за загрузку

23
00:01:27,910 --> 00:01:29,810
модуля, это команда – <i>load</i>

24
00:01:31,080 --> 00:01:34,600
Имя команды можно
сокращать до первой буквы

25
00:01:35,000 --> 00:01:36,540
написав :l

26
00:01:36,990 --> 00:01:39,720
Все команды интерпретатора
начинаются с двоеточия.

27
00:01:40,190 --> 00:01:43,146
Теперь я должен
указать имя модуля

28
00:01:44,470 --> 00:01:45,786
и вот мой модуль загружен

29
00:01:46,040 --> 00:01:49,550
Теперь я могу вызвать функции
из этого модуля, набирая

30
00:01:50,170 --> 00:01:51,970
имя этой функции.

31
00:01:52,160 --> 00:01:55,240
У нас там определена
единственная функция sayHello

32
00:01:55,330 --> 00:01:57,030
вот я могу её вызывать

33
00:01:57,240 --> 00:02:00,634
и функция делает то что
она должна делать –

34
00:02:00,659 --> 00:02:03,974
выводит соответствующую
строку в терминал.

35
00:02:04,590 --> 00:02:07,890
Крайне полезной является
возможность перезагрузки модуля

36
00:02:08,070 --> 00:02:10,560
после внесения в него
исправления в редакторе кода.

37
00:02:11,450 --> 00:02:16,910
Давайте поменяем что нибудь
в нашей программе sayHello

38
00:02:17,050 --> 00:02:19,673
ну например добавим слово World

39
00:02:21,144 --> 00:02:22,790
Сохраним эти изменения

40
00:02:23,990 --> 00:02:30,010
и передя в интерпретатор
вызовем команду интерпретатора

41
00:02:30,060 --> 00:02:33,028
<i>reload</i> – перезагрузить

42
00:02:33,620 --> 00:02:36,290
Ну, естественно, тогда
укажем имя модуля Test

43
00:02:39,810 --> 00:02:43,415
Перезагрузка произошла успешно,
никаких сообщений об ошибках

44
00:02:43,440 --> 00:02:46,340
не появилось, поэтому
мы опять можем вызвать

45
00:02:46,400 --> 00:02:48,500
нашу команду sayHello

46
00:02:49,040 --> 00:02:54,610
Мы видим теперь что у нас
изменённая функция вызывается

47
00:02:54,994 --> 00:02:59,590
и появляется слово World в том
выводе, который функция sayHello

48
00:02:59,693 --> 00:03:01,750
осуществляет на наш терминал.

49
00:03:02,770 --> 00:03:05,203
При програмирование на
Haskell, многими используется

50
00:03:05,228 --> 00:03:07,684
именно такая модель работы
с двумя открытыми окнами

51
00:03:08,390 --> 00:03:12,445
Код пишется в редакторе, и тут
же проверяется в интерпретаторе.

52
00:03:13,030 --> 00:03:16,785
Или наоборот, вырожения постепенно
проверяются в интерпретаторе

53
00:03:17,130 --> 00:03:19,530
то есть постепенно
конструируются в интерпретаторе

54
00:03:19,910 --> 00:03:23,390
и затем переносятся в редактор

55
00:03:23,540 --> 00:03:26,132
как функций, или их составные части.

